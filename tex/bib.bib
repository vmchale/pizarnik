@misc{diggins2008,
    author = {Christopher Diggins},
    title = {Simple Type Inference for Higher-Order Stack-Oriented Languages},
    year = {2008}
}
@misc{diggins2007,
    author = {Christopher Diggins},
    title = {Typing Functional Stack-Based Languages},
    year = {2007}
}
@inproceedings{ehrenberg2009,
    url={http://micsymposium.org/mics_2009_proceedings/mics2009_submission_72.pdf},
    title={Pattern matching in concatenative programming languages},
    author={Daniel Ehrenberg},
    year={2009},
    howpublished={\url{http://micsymposium.org/mics_2009_proceedings/mics2009_submission_72.pdf}}
}
@misc{expressionproblem,
    author={Philip Wadler},
    year={1998},
    title={The Expression Problem},
    howpublished={\url{https://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt}},
}
@misc{elibendersky,
    howpublished={\url{https://eli.thegreenplace.net/2018/more-thoughts-on-the-expression-problem-in-haskell/}},
    title={More thoughts on the Expression Problem in Haskell},
    author={Eli Bendersky},
    year={2018},
}
@inproceedings{blume2006,
author = {Blume, Matthias and Acar, Umut A. and Chae, Wonseok},
title = {Extensible programming with first-class cases},
year = {2006},
isbn = {1595933093},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1159803.1159836},
doi = {10.1145/1159803.1159836},
abstract = {We present language mechanisms for polymorphic, extensible records and their exact dual, polymorphic sums with extensible first-class cases. These features make it possible to easily extend existing code with new cases. In fact, such extensions do not require any changes to code that adheres to a particular programming style. Using that style, individual extensions can be written independently and later be composed to form larger components. These language mechanisms provide a solution to the expression problem.We study the proposed mechanisms in the context of an implicitly typed, purely functional language PolyR. We give a type system for the language and provide rules for a 2-phase transformation: first into an explicitly typed λ-calculus with record polymorphism, and finally to efficient index-passing code. The first phase eliminates sums and cases by taking advantage of the duality with records.We implement a version of PolyR extended with imperative features and pattern matching - we call this language MLPolyR. Programs in MLPolyR require no type annotations - the implementation employs a reconstruction algorithm to infer all types. The compiler generates machine code (currently for PowerPC) and optimizes the representation of sums by eliminating closures generated by the dual construction.},
booktitle = {Proceedings of the Eleventh ACM SIGPLAN International Conference on Functional Programming},
pages = {239–250},
numpages = {12},
keywords = {duality, first-class cases, records, sums},
location = {Portland, Oregon, USA},
series = {ICFP '06}
}

@article{10.1145/1160074.1159836,
author = {Blume, Matthias and Acar, Umut A. and Chae, Wonseok},
title = {Extensible programming with first-class cases},
year = {2006},
issue_date = {September 2006},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {41},
number = {9},
issn = {0362-1340},
url = {https://doi.org/10.1145/1160074.1159836},
doi = {10.1145/1160074.1159836},
abstract = {We present language mechanisms for polymorphic, extensible records and their exact dual, polymorphic sums with extensible first-class cases. These features make it possible to easily extend existing code with new cases. In fact, such extensions do not require any changes to code that adheres to a particular programming style. Using that style, individual extensions can be written independently and later be composed to form larger components. These language mechanisms provide a solution to the expression problem.We study the proposed mechanisms in the context of an implicitly typed, purely functional language PolyR. We give a type system for the language and provide rules for a 2-phase transformation: first into an explicitly typed λ-calculus with record polymorphism, and finally to efficient index-passing code. The first phase eliminates sums and cases by taking advantage of the duality with records.We implement a version of PolyR extended with imperative features and pattern matching - we call this language MLPolyR. Programs in MLPolyR require no type annotations - the implementation employs a reconstruction algorithm to infer all types. The compiler generates machine code (currently for PowerPC) and optimizes the representation of sums by eliminating closures generated by the dual construction.},
journal = {SIGPLAN Not.},
month = {sep},
pages = {239–250},
numpages = {12},
keywords = {duality, first-class cases, records, sums}
}
